package Genetic;
import java.util.*;

import Models.*;

import java.io.*;

public class GA  implements Runnable{

    //private Population population = new Population();
    private ArrayList<Individual> pop = new ArrayList<Individual>();
    private int generationCount = 0;
    private Individual goat;
    private int bestGen = 0;

    public static int[][] clauses;
    public static int[] pram = {0,0};
    private static Random rn = new Random();

    public static int geneCount = 0;
    public static int geneFit = 0;
    public static int wrsrFit = 0;
    // configurations
    private static String file = "uf75"; // cnf file
    private static int maxIteration = 100; // maximum number of generations
    private static int eliteSize = 200;  // size of elites pool
    private static int popSize = 4000;  // size of population pool
    private static Double mutationPercentage = .1; // percentage of the number of mutated individuals
    private static Double mutationRate = 0.9;   // mutation rate
    private static String crossoverMethod = "k-point"; // single or k-point; default single
    private static int dco = 1; // Dynamic crossover, 0 for false, 1 for increasing, -1 for decreasing
    private static double crossoverRate = 0.7;  // crossover rate, it will not be taken in consideration if the dco is activated
    private static boolean fillWithRand = true; // fill the rest of the population that was not generated by crossover with new random individuals
    private static int sleepTime = 00; // time between each two iterations
    private static boolean elitism = false; // don't worry about this

    private class SortPop implements Comparator<Individual> {
        public int compare(Individual a, Individual b){
            return b.fitness - a.fitness;
        }
    }

    public static void main(String[] args) {
        new GA().run();
    }

    private void randomPop() {
        for (int i = 0; i < popSize; i++) {
            pop.add(new Individual());
        }
    }

    private void fit() {
        pop.sort(new SortPop());
        geneCount = generationCount;
        geneFit = pop.get(0).fitness;
        wrsrFit = pop.get(popSize-1).fitness;
    }

    public void run() {
        parse(file);

        //Initialize population
        randomPop();

        //Calculate fitness of each individual
        fit();

        System.out.println("Generation: " + generationCount + " Fittest: " + pop.get(0).fitness + " / " + pram[1]);
        System.out.println("Best: ");
        System.out.print("\nf: " + pop.get(0).fitness + "\t|\t");
        goat = pop.get(0);
        for (int i = 0; i < goat.geneLength; i++) {
            System.out.print(goat.genes[i] + "\t ");
        }

        //While population gets an individual with maximum fitness
        int co = 0;
        while (co < maxIteration && goat.fitness < pram[1]) {
            co++;
            /*System.out.println("\nPopulation: ");
            for (int i = 0; i < popSize; i++) {
                System.out.print("\nf: " + pop.get(i).fitness + "\t|\t");
                for (int j = 0; j < pop.get(i).geneLength; j++) {
                    System.out.print(pop.get(i).genes[j] + "\t ");
                }
            }*/
            //population.print();
            ++generationCount;

            System.out.println();
            //Do crossover
            reproduce();

            //Do mutation under a random probability
            mutation(getMR());

            //Do selection
            fit();

            System.out.println("Generation: " + generationCount + " Fittest: " + pop.get(0).fitness + " / " + pram[1]);
/*            System.out.println("Elites: " + eliteSize);
            for (int i = 0; i < eliteSize; i++) {
                System.out.print("\nf: " + pop.get(i).fitness + "\t|\t");
                for (int j = 0; j < pop.get(i).geneLength; j++) {
                    System.out.print(pop.get(i).genes[j] + "\t ");
                }
            }*/
            try { Thread.sleep(sleepTime); } catch (Exception e) { System.out.println(e.getMessage());}

            if (pop.get(0).fitness > goat.fitness) {
                goat = pop.get(0);
                bestGen = generationCount;
            }
        }
        if (goat.fitness == pram[1])
            System.out.println("\nSolution found in generation " + generationCount);
        else
            System.out.println("\nMax number of iterations reached, no solution found.");
        System.out.println("Best generation: " + bestGen);
        System.out.print("f: " + goat.fitness + "\t|\t");
        for (int i = 0; i < goat.geneLength; i++) {
            System.out.print(goat.genes[i] + "\t ");
        }
    }

    private double getCOR() {
        switch (dco) {
            case 0 : System.out.println("Crossover rate : " + crossoverRate); return crossoverRate;
            case 1 : System.out.println("Crossover rate : " + ((double)geneCount / (double)maxIteration)); return ((double)geneCount / (double)maxIteration);
            case -1: System.out.println("Crossover rate : " + (1 - ((double)geneCount / (double)maxIteration)) ); return 1  -  ((double)geneCount / (double)maxIteration);
            default: System.out.println("Crossover rate : " + crossoverRate); return crossoverRate;
        }

    }
    //Crossover
    private Individual crossover(ArrayList<Individual> newElites) {

        int a,b;
        do {
            a = rn.nextInt(newElites.size());
            b = rn.nextInt(newElites.size());
        }while (a == b);

        Individual ind = new Individual(newElites.get(a).genes);

        if (crossoverMethod.equals("single")) {//Select a random crossover point

            int crossOverPoint = rn.nextInt(ind.geneLength);
            System.arraycopy(newElites.get(b).genes,0, ind.genes, 0, crossOverPoint);

        } else { // k-point
            for (int j = 0; j < ind.geneLength; j++) {
                if (Math.abs(rn.nextInt() % 10)>5)
                    ind.genes[j] = newElites.get(b).genes[j];
            }
        }
        /*        System.out.print("\ninserting: "); System.out.print("f: " + ind.fitness + "\t|\t"); for (int k = 0; k < ind.geneLength; k++) { System.out.print(ind.genes[k] + "\t ");}*/

        return ind;
    }

    private void reproduce() {
        ArrayList<Individual> newElites = new ArrayList<Individual>();
        ArrayList<Individual> newPop = new ArrayList<Individual>();
        for (int i = 0; i < eliteSize; i++) {
            newElites.add(pop.get(i));
        }
        int start = 0;

        if (elitism) {
            // adding the elites
            for (int i = 0; i < eliteSize; i++) {
                newPop.add(newElites.get(i));
            }
            start = eliteSize;
        }

        Double cor = getCOR();
        // adding the new offspring
        for (int i = start; i < (int)(popSize * cor); i++) { //
            newPop.add(crossover(newElites));
        }

        // fill the rest of new individuals or old offspring
        if (fillWithRand) {
            for (int i = (int)(popSize * cor); i < popSize; i++) {
                newPop.add(new Individual());
            }
        } else {
            for (int i = (int)(popSize * cor); i < popSize; i++) {
                newPop.add( pop.get(    rn.nextInt(popSize)   )   );
            }
        }
        pop = newPop;
    }

    private double getMR() {
        switch (dco) {
            case 0 : System.out.println("Mutation rate : " + mutationRate); return mutationRate;
            case 1 : System.out.println("Mutation rate : " + (1 - ((double)geneCount / (double)maxIteration)) ); return 1  -  ((double)geneCount / (double)maxIteration);
            case -1: System.out.println("Mutation rate : " + ((double)geneCount / (double)maxIteration)); return ((double)geneCount / (double)maxIteration);
            default: System.out.println("Mutation rate : " + mutationRate); return mutationRate;
        }

    }
    //Mutation
    private void mutation(double mtr) {
        // picking random individuals
        int end = (mtr == 0.0) ? 0 : rn.nextInt((int)(popSize * mtr));
        for (int i = 0; i < end; i++) {

            int ind_index = rn.nextInt(popSize);
            if (elitism)
                ind_index=+eliteSize;
            // mutate few genes

            for (int j = 0; j < (int)(pop.get(ind_index).geneLength * mutationPercentage); j++) {
                //Select a random mutation point
                int mutationPoint = rn.nextInt(pop.get(ind_index).geneLength);

                //System.out.println("Muatation to ind: " + ind_index + " at: " + mutationPoint);
                //Flip values at the mutation point
                pop.get(ind_index).genes[mutationPoint] = (pop.get(ind_index).genes[mutationPoint] == -1) ? 1 : -1;
            }
        }
    }

    private static void parse(String fname) {
        try {
            //the file to be opened for reading
            FileInputStream fis=new FileInputStream("C:/Users/ali25/Desktop/Gene_SAT/src/cnf/" + fname + ".cnf");
            Scanner sc=new Scanner(fis);    //file to be scanned

            if (sc.hasNextLine()) {
                String[] tmp = sc.nextLine().split(" ");
                pram[0] = Integer.valueOf( tmp[0]);
                pram[1] = Integer.valueOf( tmp[1]);
                clauses = new int[pram[1]][pram[0]];
                System.out.println("[!] Creating matrix: " + pram[0] + "x" + pram[1]);
                for (int i = 0; i < pram[1]; i++) {
                    String[] vars = sc.nextLine().split(" ");
                    for (String var : vars) {
                        if( ! var.equals("") && !var.equals("\t")) {
                            int iv = Integer.valueOf(var);
                            if (iv != 0){
                                clauses[i][Math.abs(iv)-1] = Integer.signum(iv);
                            }
                        }
                    }
                }
                System.out.println("");
            }
            sc.close();     //closes the scanner
/*            for (int i = 0; i < pram[1]; i++) {
                System.out.print("\n c:" + i);
                for (int j = 0; j < pram[0]; j++) {
                    System.out.print("\t" + clauses[i][j]);
                }
                System.out.println();
            }*/
        }
        catch(IOException e) {
            e.printStackTrace();
        }
    }

    public static int validate(int[] solution) {
        int c = 0;
        for(int[] clause : clauses) {
            if (check(clause, solution)) c++;
        }
        return c;
    }

    static boolean check(int[] clause, int[] solution) {
        for (int i = 0; i < clause.length; i++) {
            if (clause[i] == 0)
                continue;

            if (clause[i] == solution[i])
                return true;
        }
        return false;
    }
}